<!DOCTYPE html>
<html>
<head>
    <title>rBrowser v1.0 - NomadNet Nodes Standalone Page Browser</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="main">
        <div class="sidebar" style="position: relative; max-width: 210px !important;">
            <div class="search-container">
                <div class="search-wrapper">
                    <input type="text" class="node-search" id="node-search" placeholder="Search nodes by name or hash..." onkeyup="filterNodes()" oninput="toggleClearButton()">
                    <button class="search-clear" id="search-clear" onclick="clearSearch()" style="display: none;">×</button>
                </div>
            </div>
            <div class="favorites-section" id="favorites-section" style="background: #21262d; border-bottom: 1px solid #30363d; padding: 8px; flex-shrink: 0; z-index: 100; position: relative;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                    <span style="color: #ffa657; font-size: 12px; font-weight: bold;">⭐ Favorites</span>
                    <button id="favorites-toggle" onclick="toggleFavoritesSection()" style="background: none; border: none; color: #7d8590; cursor: pointer; font-size: 10px;">Hide</button>
                </div>
                <div class="favorites-list" id="favorites-list" style="background: #161b22; padding: 4px; border-radius: 4px; min-height: 20px;">
                    <div style="text-align: center; color: #7d8590; font-size: 11px; padding: 8px;">No favorites yet</div>
                </div>
            </div>
            <div class="node-list-container" style="position: absolute !important; top: 50px !important; bottom: 38px !important; left: 0 !important; right: 0 !important; overflow-y: auto !important;">
                <div class="node-list" id="node-list">
                    <div style="text-align: center; padding: 20px; color: #7d8590; font-size: 12px;">Scanning for nodes...</div>
                </div>
            </div>
            <div class="status-bar" style="position: absolute !important; bottom: 0 !important; left: 0 !important; right: 0 !important; padding: 4px 8px !important; margin: 0 !important; font-size: 12px !important; line-height: 1.1 !important; height: 38px !important; min-height: 38px !important; max-height: 38px !important; box-sizing: border-box !important;">
                Status:<span class="online"><strong> ● Online.  Reticulum Connected!</strong></span><br>
                Total Announces: <span class="count" id="announce-count">0</span> - NomadNet Nodes: <span class="count" id="node-count">0</span>                
            </div>
        </div>
            <div class="content">
            <!-- NEW: Tab bar section -->
            <div class="tab-bar">
                <div class="tabs-container" id="tabs-container">
                    <!-- Tabs will be dynamically created here -->
                </div>
                <button class="new-tab-btn" onclick="createNewTab()">+ New Tab</button>
            </div>
            
            <!-- MODIFIED: Tab content wrapper (replaces your existing nav-bar, header, browser-area) -->
            <div class="tab-content-wrapper" id="tab-content-wrapper">
                <!-- Each tab will have its own content area -->
            </div>
        </div>
    </div>

    <template id="tab-content-template">
    <div class="tab-content">

        <div class="nav-bar">
            <div class="nav-controls">
                <button class="nav-btn back-btn" onclick="navigateBack()" disabled>←</button>
                <button class="nav-btn forward-btn" onclick="navigateForward()" disabled>→</button>
                <button class="nav-btn" onclick="refreshPage()">⟳</button>
            </div>
            <input type="text" class="address-bar" id="address-bar" placeholder="Enter NomadNet URL (hash:/path/to/page.mu)" onkeypress="handleAddressBarEnter(event)">
            <button class="go-btn" onclick="navigateToUrl()">Go</button>
        </div>

        <div class="header">
            <div class="page-info">
                <span class="page-title"><center>Select a node from the announce list, favorites, or paste an address into the bar to navigate pages.</center></span>
                <span class="page-details"></span>
            </div>
            <button class="view-toggle">Raw View</button>
        </div>

        <div class="browser-area">
            <div class="page-content">
                <div class="welcome">
                    <h2>rBrowser v1.0</h2>
                    <p>Welcome to the NomadNet Standalone Browser.<br>This browser connects to Reticulum and listens for NomadNetwork Nodes serving pages.<br>Wait for announces and select a node from the sidebar to explore the distributed content.</p>
                </div>
            </div>
        </div>

        <div class="shortcuts-bar">
            <span class="shortcut-item">
                Browser Shortcuts: <kbd>Alt + N</kbd> Open New Tab
            </span>
            <span class="shortcut-item">
                <kbd>Alt + X</kbd> Close Current Tab
            </span>
            <span class="shortcut-item">
                <kbd>Alt + B</kbd> Reload Current Page
            </span>
            <span class="shortcut-item">
                <kbd>Ctrl + ← or →</kbd> Switch Tabs Left or Right
            </span>
            <span class="shortcut-item">
                <kbd>Ctrl + X</kbd> Close all other tabs
            </span>
        </div>

    </div>
</template>

    <!-- Load local DOMPurify js for security -->
    <script src="../script/purify.min.js"></script>

    <script>
        let selectedNode = null;
        let currentRequest = null;
        let currentRawContent = '';
        let isRawView = false;
        let micronParser = null;
        let isOriginalParser = false;
        let navigationHistory = [];
        let historyIndex = -1;
        let currentUrl = '';
        let cachedNodes = [];
        let favoriteNodes = [];
        let tabs = [];
        let activeTabId = null;
        let tabCounter = 0;

// Tab class to manage individual tab state
class BrowserTab {
    constructor(id) {
        this.id = id;
        this.title = 'New Tab';
        this.url = '';
        this.loading = false;
        this.selectedNode = null;
        this.currentRequest = null;
        this.currentRawContent = '';
        this.isRawView = false;
        this.navigationHistory = [];
        this.historyIndex = -1;
        this.currentUrl = '';
        this.knownNodeName = null;
    }
    
    setTitle(title) {
        this.title = title || 'New Tab';
        this.updateTabDisplay();
    }
    
    setUrl(url) {
        this.url = url;
        this.currentUrl = url;
        this.updateAddressBar();
    }
    
    setLoading(loading) {
        this.loading = loading;
        this.updateTabDisplay();
    }
    
    addToHistory(url) {
        if (url !== this.currentUrl) {
            this.navigationHistory = this.navigationHistory.slice(0, this.historyIndex + 1);
            this.navigationHistory.push(url);
            this.historyIndex = this.navigationHistory.length - 1;
            this.currentUrl = url;
            this.updateNavigationButtons();
        }
    }
    
    updateTabDisplay() {
        const tabElement = document.querySelector(`[data-tab-id="${this.id}"]`);
        if (tabElement) {
            const titleElement = tabElement.querySelector('.tab-title');
            titleElement.textContent = this.loading ? 'Loading...' : this.title;
            tabElement.classList.toggle('loading', this.loading);
        }
    }
    
    updateAddressBar() {
        if (this.id === activeTabId) {
            const addressBar = document.querySelector(`#${this.id} .address-bar`);
            if (addressBar) {
                addressBar.value = this.url;
            }
        }
    }
    updateNavigationButtons() {
        if (this.id === activeTabId) {
            const backBtn = document.querySelector(`#${this.id} .back-btn`);
            const forwardBtn = document.querySelector(`#${this.id} .forward-btn`);
            
            if (backBtn) backBtn.disabled = this.historyIndex <= 0;
            if (forwardBtn) forwardBtn.disabled = this.historyIndex >= this.navigationHistory.length - 1;
        }
    }
    
}


// NEW TAB MANAGEMENT FUNCTIONS
function createNewTab() {
    const tabId = `tab-${++tabCounter}`;
    const tab = new BrowserTab(tabId);
    tabs.push(tab);
    
    createTabElement(tab);
    createTabContent(tab);
    switchToTab(tabId);
    
    return tab;
}

function createTabElement(tab) {
    const tabsContainer = document.getElementById('tabs-container');
    
    const tabElement = document.createElement('div');
    tabElement.className = 'tab';
    tabElement.setAttribute('data-tab-id', tab.id);
    tabElement.innerHTML = `
        <span class="tab-title">${tab.title}</span>
        <span class="tab-close" onclick="closeTab('${tab.id}', event)">&times;</span>
    `;
    
    tabElement.addEventListener('click', (e) => {
        if (!e.target.classList.contains('tab-close')) {
            switchToTab(tab.id);
        }
    });
    
    tabsContainer.appendChild(tabElement);
}

function createTabContent(tab) {
    const wrapper = document.getElementById('tab-content-wrapper');
    const template = document.getElementById('tab-content-template');
    const clone = template.content.cloneNode(true);
    
    const content = clone.querySelector('.tab-content');
    content.id = tab.id;
    
    // Add event listeners to the cloned elements
    const backBtn = content.querySelector('.back-btn');
    const forwardBtn = content.querySelector('.forward-btn');
    const refreshBtn = content.querySelector('.refresh-btn');
    const goBtn = content.querySelector('.go-btn');
    const addressBar = content.querySelector('.address-bar');
    const viewToggle = content.querySelector('.view-toggle');
    
    if (backBtn) backBtn.onclick = () => navigateBackTab();
    if (forwardBtn) forwardBtn.onclick = () => navigateForwardTab();
    if (refreshBtn) refreshBtn.onclick = () => refreshPageTab();
    if (goBtn) goBtn.onclick = () => navigateToUrlTab();
    if (addressBar) addressBar.onkeypress = (e) => handleAddressBarEnterTab(e);
    if (viewToggle) viewToggle.onclick = () => toggleViewTab();
    
    wrapper.appendChild(content);
}

function switchToTab(tabId) {
    activeTabId = tabId;
    
    // Remove active class from all tabs and content
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    
    // Add active class to selected tab and content
    const tabElement = document.querySelector(`[data-tab-id="${tabId}"]`);
    const contentElement = document.getElementById(tabId);
    
    if (tabElement && contentElement) {
        tabElement.classList.add('active');
        contentElement.classList.add('active');
        
        // Update the active tab's state
        const activeTab = getActiveTab();
        if (activeTab) {
            activeTab.updateAddressBar();
            activeTab.updateNavigationButtons();
        }
    }
}

function closeTab(tabId, event) {
    if (event) {
        event.stopPropagation();
    }
    
    const tabIndex = tabs.findIndex(t => t.id === tabId);
    if (tabIndex === -1) return;
    
    // Don't close if it's the only tab
    if (tabs.length === 1) {
        return;
    }
    
    // Remove tab from array
    tabs.splice(tabIndex, 1);
    
    // Remove DOM elements
    document.querySelector(`[data-tab-id="${tabId}"]`)?.remove();
    document.getElementById(tabId)?.remove();
    
    // If this was the active tab, switch to another
    if (activeTabId === tabId) {
        const nextTab = tabs[Math.max(0, tabIndex - 1)];
        switchToTab(nextTab.id);
    }
}

function getActiveTab() {
    return tabs.find(t => t.id === activeTabId);
}

// MODIFIED VERSIONS OF YOUR EXISTING FUNCTIONS FOR TABS
function navigateBackTab() {
    const tab = getActiveTab();
    if (tab && tab.historyIndex > 0) {
        tab.historyIndex--;
        const url = tab.navigationHistory[tab.historyIndex];
        tab.setUrl(url);
        navigateToUrlInternalTab(url, false);
        tab.updateNavigationButtons();
    }
}

function navigateForwardTab() {
    const tab = getActiveTab();
    if (tab && tab.historyIndex < tab.navigationHistory.length - 1) {
        tab.historyIndex++;
        const url = tab.navigationHistory[tab.historyIndex];
        tab.setUrl(url);
        navigateToUrlInternalTab(url, false);
        tab.updateNavigationButtons();
    }
}

function refreshPageTab() {
    const tab = getActiveTab();
    if (tab && tab.currentUrl) {
        navigateToUrlInternalTab(tab.currentUrl, false);
    }
}

function navigateToUrlTab() {
    const tab = getActiveTab();
    if (tab) {
        const addressBar = document.querySelector(`#${tab.id} .address-bar`);
        if (addressBar && addressBar.value) {
            navigateToUrlInternalTab(addressBar.value, true);
        }
    }
}

function handleAddressBarEnterTab(event) {
    if (event.key === 'Enter') {
        navigateToUrlTab();
    }
}

async function navigateToUrlInternalTab(url, addHistory = true) {
    const tab = getActiveTab();
    if (!tab) return;
    
    const parsed = parseNomadNetUrl(url);
    if (!parsed) {
        alert('Invalid NomadNet URL format. Examples:\n- abcd1234...:/page/index.mu\n- nomadnetwork://abcd1234.../page/index.mu');
        return;
    }

    if (addHistory) {
        tab.addToHistory(url);
    }

    tab.setUrl(url);
    
    // NEW: Refresh cached nodes before fetching page to get latest node names
    try {
        const response = await fetch('/api/nodes');
        const nodes = await response.json();
        cachedNodes = nodes;
        console.log('Refreshed cached nodes for manual navigation:', cachedNodes.length, 'nodes');
    } catch (error) {
        console.warn('Failed to refresh cached nodes:', error);
    }
    
    fetchPageByUrlTab(parsed.hash, parsed.path, url);
}

function toggleViewTab() {
    const tab = getActiveTab();
    if (!tab) return;
    
    const content = document.querySelector(`#${tab.id} .page-content`);
    const toggle = document.querySelector(`#${tab.id} .view-toggle`);
    
    if (tab.isRawView) {
        // Switch to rendered view
        const renderedHtml = parseMicronContent(tab.currentRawContent);
        content.innerHTML = renderedHtml;
        content.className = 'page-content';
        
        // Re-add click handlers
        addClickHandlersToCurrentTab();
        
        toggle.textContent = 'Raw View';
        tab.isRawView = false;
    } else {
        // Switch to raw view
        content.innerHTML = escapeHtml(tab.currentRawContent);
        content.className = 'page-content raw';
        toggle.textContent = 'Rendered View';
        tab.isRawView = true;
    }
}

function addClickHandlersToCurrentTab() {
    const tab = getActiveTab();
    if (!tab) return;
    
    const links = document.querySelectorAll(`#${tab.id} .page-content a`);
    
    function handleClick(event) {
        event.preventDefault();
        const action = this.getAttribute('data-action');
        const destination = this.getAttribute('data-destination');
        const fields = this.getAttribute('data-fields');
        
        if (destination && destination.includes('lxmf@')) {
            alert("This is an LXMF address, use official LXMF clients to open this link and chat with the peer (MeshChat, Sideband)");
            return;
        }
        
        if (destination && (destination.includes('http://') || destination.includes('https://'))) {
            let httpUrl = destination;
            if (destination.startsWith('nomadnetwork://')) {
                httpUrl = destination.replace('nomadnetwork://', '');
            }
            const userConfirmed = confirm("Open HTTP/HTTPS URL in a new browser window?\n\nURL: " + httpUrl);
            if (userConfirmed) {
                window.open(httpUrl, '_blank', 'noopener,noreferrer');
            }
            return;
        }
        
        navigateToLinkTab(destination);
    }

    links.forEach(link => {
        link.addEventListener('click', handleClick);
    });
}

// REPLACE your navigateToLinkTab function with this fixed version:
function navigateToLinkTab(url, addHistory = true) {
    const tab = getActiveTab();
    if (!tab) return;
    
    console.log('navigateToLinkTab called with URL:', url);
    
    const parsedCurrent = parseNomadNetUrl(tab.currentUrl);
    if (!parsedCurrent) {
        alert('Invalid NomadNet URL format. Examples:\n- abcd1234...:/page/index.mu\n- nomadnetwork://abcd1234.../page/index.mu');
        return;
    }

    let parsed = parseNomadNetUrl(url);
    if (!parsed) {
        // Handle relative URLs (starting with : or /)
        if (url.startsWith(':')) {
            // Remove the leading : and construct full URL
            const relativePath = url.substring(1);
            const fullUrl = `${parsedCurrent.hash}:${relativePath}`;
            console.log('Constructed full URL from relative:', fullUrl);
            parsed = parseNomadNetUrl(fullUrl);
            url = fullUrl; // Update url variable too
        } else if (url.startsWith('/')) {
            // Path starts with /, construct full URL
            const fullUrl = `${parsedCurrent.hash}:${url}`;
            console.log('Constructed full URL from path:', fullUrl);
            parsed = parseNomadNetUrl(fullUrl);
            url = fullUrl; // Update url variable too
        } else {
            // Assume it's a relative path without leading /
            const fullUrl = `${parsedCurrent.hash}:/${url}`;
            console.log('Constructed full URL from relative path:', fullUrl);
            parsed = parseNomadNetUrl(fullUrl);
            url = fullUrl; // Update url variable too
        }
    }

    // Final check
    if (!parsed) {
        console.error('Failed to parse URL after all attempts:', url);
        return;
    }

    if (addHistory) {
        tab.addToHistory(url);
    }

    console.log('Final parsed result:', parsed);
    console.log('Final URL being used:', url);
    
    tab.setUrl(url);
    fetchPageByUrlTab(parsed.hash, parsed.path, url);
}

function fetchPageByUrlTab(hash, path, originalUrl) {
    const tab = getActiveTab();
    if (!tab) return;
    
    if (tab.currentRequest) {
        tab.currentRequest.abort();
        tab.currentRequest = null;
    }
    
    tab.selectedNode = hash;
    tab.setLoading(true);


    const nodeName = tab.knownNodeName || getNodeName(hash);
    const pageTitle = document.querySelector(`#${tab.id} .page-title`);
    const pageUrl = document.querySelector(`#${tab.id} .page-url`);
    const pageContent = document.querySelector(`#${tab.id} .page-content`);
    const viewToggle = document.querySelector(`#${tab.id} .view-toggle`);
    const addressBar = document.querySelector(`#${tab.id} .address-bar`);
    
    if (pageTitle) {
        pageTitle.innerHTML = `<span class="label">Loading:</span> <span class="value">${nodeName}</span>`;
    }
    const pageDetails = document.querySelector(`#${tab.id} .page-details`);
    if (pageDetails) {
        pageDetails.innerHTML = `<span class="label">Page Path:</span> <span class="value">${path}</span> <span class="label">Full Address:</span> <span class="value">${originalUrl}</span>`;
    }
    if (pageContent) pageContent.innerHTML = `<div style="color: #58a6ff; text-align: center; padding: 40px; font-size: 16px;">Loading NomadNet page:<br><br><strong>${nodeName}</strong><br><br>Please wait...</div>`;
    if (viewToggle) viewToggle.style.display = 'none';
    if (addressBar) addressBar.value = originalUrl;
    
    tab.setTitle(`Loading ${nodeName}...`);
    
    // Update selected node in sidebar
    document.querySelectorAll('.node-item').forEach(item => item.classList.remove('selected'));
    const nodeItem = document.querySelector(`[data-hash="${hash}"]`);
    if (nodeItem) {
        nodeItem.classList.add('selected');
    }
    
    const controller = new AbortController();
    tab.currentRequest = controller;

    console.log('Sending request to server:', `/api/fetch/${hash}?path=${encodeURIComponent(path)}`);
    console.log('Raw path before encoding:', path);

    fetch(`/api/fetch/${hash}?path=${encodeURIComponent(path)}`, { signal: controller.signal })
        .then(r => r.json())
        .then(response => {
            if (tab.currentRequest === controller) {
                if (response.status === 'success') {
                    tab.currentRawContent = response.content;
                    tab.isRawView = false;
                    
                    const renderedHtml = parseMicronContent(response.content);
                    if (pageContent) pageContent.innerHTML = renderedHtml;
                    if (pageContent) pageContent.className = 'page-content';
                    
                    if (pageTitle) {
                        pageTitle.innerHTML = `<span class="node-name">${nodeName}</span>`;
                    }
                    const pageDetails = document.querySelector(`#${tab.id} .page-details`);
                    if (pageDetails) {
                        pageDetails.innerHTML = `<span class="path-info">${path}</span> <span class="label">- Address:</span> <span class="address-info">${originalUrl}</span>`;
                    }
                    
                    if (viewToggle) {
                        viewToggle.style.display = 'block';
                        viewToggle.textContent = 'Raw View';
                    }
                    
                    tab.setTitle(nodeName);
                    addClickHandlersToCurrentTab();
                    
                } else {
                    if (pageContent) pageContent.innerHTML = `<div class="error">Failed to load page: ${escapeHtml(response.error)}<br><br>This could be due to network issues or the node being offline.</div>`;
                    if (pageTitle) pageTitle.textContent = `Error loading ${originalUrl}`;
                    if (pageUrl) pageUrl.textContent = '';
                    if (viewToggle) viewToggle.style.display = 'none';
                    tab.setTitle('Error');
                }
                tab.currentRequest = null;
                tab.setLoading(false);
            }
        })
        .catch(err => {
            if (tab.currentRequest === controller && !controller.signal.aborted) {
                if (pageContent) pageContent.innerHTML = `<div class="error">Network error: ${escapeHtml(err.message)}<br><br>Please check your connection and try again.</div>`;
                if (pageTitle) pageTitle.textContent = `Error loading ${originalUrl}`;
                if (pageUrl) pageUrl.textContent = '';
                if (viewToggle) viewToggle.style.display = 'none';
                tab.currentRequest = null;
                tab.setLoading(false);
                tab.setTitle('Network Error');
            }
        });
}


        // Get Node Name function
        function getNodeName(hash) {
            console.log('Looking for hash:', hash);
            console.log('Cached nodes available:', cachedNodes.length);
    
            // First try to find in DOM
            const nodeItem = document.querySelector(`[data-hash="${hash}"]`);
            if (nodeItem) {
                const nodeName = nodeItem.getAttribute('data-name');
                console.log('Getting node name for hash:', hash, '-> Name (from DOM):', nodeName);
                return nodeName;
            }
    
            // If not in DOM, check cached nodes data
            const cachedNode = cachedNodes.find(node => {
                console.log('Comparing:', hash, 'vs', node.hash);
                return node.hash === hash;
            });
    
            if (cachedNode) {
                console.log('Getting node name for hash:', hash, '-> Name (from cache):', cachedNode.name);
                return cachedNode.name;
            }
    
            console.log('Getting node name for hash:', hash, '-> Name (fallback):', hash);
            return hash;
        }

        // Initialize MicronParser
        async function initializeMicronParser() {
            try {
                console.log('Initializing MicronParser...');
                
                // Load the original micron parser script
                await new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = './script/micron-parser_original.js';
                    script.onload = resolve;
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
                
                // Wait for script to execute
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // Try to initialize the parser
                if (typeof window.MicronParser === 'function') {
                    micronParser = new window.MicronParser(true, true);
                    isOriginalParser = true;
                    console.log('✅ Original MicronParser loaded successfully');
                } else {
                    throw new Error('MicronParser not available');
                }
            } catch (error) {
                console.warn('⚠️ Original parser failed, using fallback:', error.message);
                micronParser = createFallbackParser();
                isOriginalParser = false;
            }
        }

        function createFallbackParser() {
            return {
                convertMicronToHtml: function(text) {
                    let html = text;
                    
                    // Basic Micron formatting (simplified)
                    html = html.replace(/`!([^`]*)`!/g, '<strong style="color: #58a6ff; font-weight: bold;">$1</strong>');
                    html = html.replace(/`\*([^`]*)`\*/g, '<em style="color: #ffa657; font-style: italic;">$1</em>');
                    html = html.replace(/`_([^`]*)`_/g, '<span style="text-decoration: underline; color: #79c0ff;">$1</span>');
                    html = html.replace(/^>([^\n]*)/gm, '<div style="color: #58a6ff; font-weight: bold; font-size: 18px; margin: 16px 0 8px 0; border-bottom: 1px solid #30363d; padding-bottom: 4px;">$1</div>');
                    html = html.replace(/\n/g, '<br>');
                    
                    // Escape HTML
                    html = escapeHtml(html);
                    
                    return `<div style="font-family: 'Courier New', 'Liberation Mono', 'DejaVu Sans Mono', Courier, monospace; line-height: 1.6;">${html}</div>`;
                }
            };
        }

        function parseMicronContent(content) {
            if (!content) return '';
            
            console.log('Parsing Micron content, length:', content.length);
            
            if (micronParser) {
                let html = micronParser.convertMicronToHtml(content);
                
                // Add click handlers to any links that the original parser created
                html = addClickHandlersToLinks(html);
                
                console.log('Micron parsing complete');
                return html;
            } else {
                console.log('No parser available, returning escaped HTML');
                return escapeHtml(content);
            }
        }

        function addClickHandlersToLinks(html) {
            // Find existing <a> tags and add navigation handlers if they look like NomadNet URLs
            return html.replace(/<a([^>]*?)href=["']([^"']*?)["']([^>]*?)>/g, function(match, before, href, after) {
                // Check if it's a NomadNet URL format
                if (isNomadNetUrl(href)) {
                    const url = normalizeNomadNetUrl(href);
                    return `<a${before} href="#" class="nomadnet-link" onclick="navigateToNomadNetUrl('${url}'); return false;" title="Navigate to ${url}"${after}>`;
                }
                return match; // Keep other links as-is
            });
        }

        function isNomadNetUrl(url) {
            // Check if URL looks like a NomadNet URL
            return url.match(/^(nomadnetwork:\/\/|[a-fA-F0-9<>:]{32,}[:\/])/);
        }

        function normalizeNomadNetUrl(url) {
            // Convert various formats to our standard format: hash:/path
            if (url.startsWith('nomadnetwork://')) {
                const match = url.match(/nomadnetwork:\/\/([a-fA-F0-9<>:]+)(\/.*)?/);
                if (match) {
                    const cleanHash = match[1].replace(/[<>:]/g, '');
                    const path = match[2] || '/page/index.mu';
                    return `${cleanHash}:${path}`;
                }
            }
            return url;
        }

        function navigateToNomadNetUrl(url) {
            console.log('Link clicked! Navigating to:', url);
            const tab = getActiveTab();
            if (tab) {
                const addressBar = document.querySelector(`#${tab.id} .address-bar`);
                if (addressBar) addressBar.value = url;
                navigateToUrl();
            }
        }

        function parseNomadNetUrl(url) {
            console.log('Parsing URL:', url);
            
            // Clean up common URL prefixes
            url = url.replace(/^nomadnetwork:\/\//, '');
            
            // Match hash and optional path (including parameters after backtick)
            const match = url.match(/^([a-fA-F0-9<>:]{32,})(?:[:\/](.*))?$/);
            if (match) {
                const cleanHash = match[1].replace(/[<>:]/g, '');
                let path = match[2];
                
                // Default to index page if no path
                if (!path || path === '') {
                    path = 'page/index.mu';
                }
                
                // Ensure path starts with /
                if (!path.startsWith('/')) {
                    path = '/' + path;
                }
                
                console.log('Parsed URL - Hash:', cleanHash.substring(0, 16) + '...', 'Path:', path);
                console.log('Full path including parameters:', path);
                return { hash: cleanHash, path: path };
            }
            
            console.log('Failed to parse URL:', url);
            return null;
        }

        function addToHistory(url) {
            const tab = getActiveTab();
            if (tab) {
                tab.addToHistory(url);
            }
        }

        function updateNavigationButtons() {
            const tab = getActiveTab();
            if (tab) {
                tab.updateNavigationButtons();
            }
        }

        function navigateBack() {
            navigateBackTab();
        }

        // REPLACE your original navigateForward function:
        function navigateForward() {
            navigateForwardTab();
        }

        function refreshPage() {
            refreshPageTab();
        }

        function handleAddressBarEnter(event) {
            if (event.key === 'Enter') {
                navigateToUrlTab();
            }
        }

        function navigateToUrl() {
            navigateToUrlTab();
        }

        function navigateToUrlInternal(url, addHistory = true) {
            navigateToUrlInternalTab(url, addHistory);
        }

        function navigateToLink(url, addHistory = true) {
            navigateToLinkTab(url, addHistory);
        }

        function fetchPageByUrl(hash, path, originalUrl) {
            fetchPageByUrlTab(hash, path, originalUrl);
        }

        function toggleView() {
            toggleViewTab();
        }

        function updateNodes() {
            fetch('/api/nodes')
                .then(r => r.json())
                .then(nodes => {
                    cachedNodes = nodes;
                    console.log('Cached nodes updated:', cachedNodes.length, 'nodes');
                    console.log('First cached node hash example:', cachedNodes.length > 0 ? cachedNodes[0].hash : 'none');
                    const list = document.getElementById('node-list');
                    const searchTerm = document.getElementById('node-search').value.toLowerCase(); // Save current search
           
                    if (nodes.length === 0) {
                        list.innerHTML = '<div style="text-align: center; padding: 20px; color: #7d8590; font-size: 12px;">Scanning for NomadNet Nodes...</div>';
                        return;
                    }
           
                    let html = '';
                    nodes.forEach((node, i) => {
                        const activeTab = getActiveTab();
                        const selected = (activeTab && activeTab.selectedNode === node.hash) ? 'selected' : '';
                
                        // Check if this node is favorited
                        const isFavorite = favoriteNodes.some(fav => fav.hash === node.hash);
                        const starIcon = isFavorite ? '★' : '☆';
                        const starColor = isFavorite ? '#ffa657' : '#7d8590';
                
                        html += `
                            <div class="node-item ${selected}" id="node-${i}" data-hash="${escapeHtml(node.hash)}" data-name="${escapeHtml(node.name)}">
                                <div style="position: relative;">
                                    <button class="star-btn" onclick="toggleFavorite('${node.hash}', '${escapeHtml(node.name)}'); event.stopPropagation();" 
                                            style='position: absolute; top: 0; right: 0; background: none; border: none; color: ${starColor}; cursor: pointer; font-size: 25px; padding: 4px; z-index: 10;'>${starIcon}</button>
                                    <div class="node-title">${escapeHtml(node.name)}</div>
                                    <div class="node-hash">${node.hash}</div>
                                    <div class="node-info">📊 ${node.app_data_length} bytes announced • ${node.last_seen_relative}</div>
                                </div>
                            </div>
                        `;
                    });
            
                    list.innerHTML = html;
            
                    // Reapply search filter if there was one
                    if (searchTerm) {
                        filterNodes();
                    }
            
                    document.querySelectorAll('.node-item').forEach(item => {
                        item.addEventListener('click', function(e) {
                            const hash = this.getAttribute('data-hash');
                            const name = this.getAttribute('data-name');
                            browseNode(hash, name);
                        });
                    });
            
                    document.getElementById('node-count').textContent = nodes.length;
                });
        }
        
        function updateStatus() {
            fetch('/api/status')
                .then(r => r.json())
                .then(data => {
                    document.getElementById('announce-count').textContent = data.total_announces;
                });
        }
        
        function browseNode(hash, name) {
            const url = `${hash}:/page/index.mu`;
            console.log('Browsing node:', name, 'URL:', url);
            
            const currentTab = getActiveTab();
            let targetTab;
            
            // Check if current tab is empty (new tab with default content)
            if (currentTab && currentTab.title === 'New Tab' && !currentTab.currentUrl) {
                // Use existing empty tab
                targetTab = currentTab;
            } else {
                // Create new tab if current tab has content
                targetTab = createNewTab();
            }
            
            const addressBar = document.querySelector(`#${targetTab.id} .address-bar`);
            if (addressBar) addressBar.value = url;
            
            // Store the known name in the target tab
            targetTab.knownNodeName = name;
            
            navigateToUrlInternalTab(url, true);
        }
                
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function filterNodes() {
            const searchTerm = document.getElementById('node-search').value.toLowerCase();
            const nodeItems = document.querySelectorAll('.node-item');
    
            nodeItems.forEach(item => {
                const name = item.getAttribute('data-name').toLowerCase();
                const hash = item.getAttribute('data-hash').toLowerCase();
        
                if (name.includes(searchTerm) || hash.includes(searchTerm)) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            });
    
            // Update visible count
            const visibleNodes = document.querySelectorAll('.node-item[style*="block"], .node-item:not([style*="none"])').length;
            if (searchTerm) {
                console.log(`Filtered to ${visibleNodes} nodes matching "${searchTerm}"`);
            }
        }

        function toggleClearButton() {
            const searchInput = document.getElementById('node-search');
            const clearButton = document.getElementById('search-clear');
            
            if (searchInput.value.length > 0) {
                clearButton.style.display = 'flex';
            } else {
                clearButton.style.display = 'none';
            }
        }

        function clearSearch() {
            const searchInput = document.getElementById('node-search');
            const clearButton = document.getElementById('search-clear');
            
            searchInput.value = '';
            clearButton.style.display = 'none';
            filterNodes(); // Reapply filter (which will show all nodes)
            searchInput.focus(); // Keep focus on search input
        }

        function loadFavorites() {
            const stored = localStorage.getItem('nomadnet-favorites');
            favoriteNodes = stored ? JSON.parse(stored) : [];
            updateFavoritesDisplay();
            
            // Start with favorites list closed
            const list = document.getElementById('favorites-list');
            const button = document.getElementById('favorites-toggle');
            if (list && button) {
                list.style.display = 'none';
                button.textContent = 'Show';
            }
        }

        function saveFavorites() {
            localStorage.setItem('nomadnet-favorites', JSON.stringify(favoriteNodes));
        }

        function toggleFavorite(hash, name) {
            console.log('toggleFavorite called with:', hash, name);
            const existing = favoriteNodes.findIndex(fav => fav.hash === hash);
    
            if (existing >= 0) {
                favoriteNodes.splice(existing, 1);
                console.log('Removed favorite, new count:', favoriteNodes.length);
            } else {
                favoriteNodes.push({ hash: hash, name: name });
                console.log('Added favorite, new count:', favoriteNodes.length);
            }
    
            saveFavorites();
            updateFavoritesDisplay();
            updateNodes(); // Refresh to update star icons
        }

        function updateFavoritesDisplay() {
            console.log('updateFavoritesDisplay called, favoriteNodes:', favoriteNodes);
            const list = document.getElementById('favorites-list');
            
            if (favoriteNodes.length === 0) {
                list.innerHTML = '<div style="text-align: center; color: #7d8590; font-size: 11px; padding: 8px;">No favorites yet</div>';
                return;
            }
            
            let html = '';
            favoriteNodes.forEach((fav, index) => {
                html += `
                    <div class="favorite-item" style="background: #0d1117; padding: 4px 6px; margin: 2px 0; border-radius: 3px; border: 1px solid #30363d; display: flex; justify-content: space-between; align-items: center;">
                        <span onclick="browseNode('${fav.hash}', '${fav.name}')" style="cursor: pointer; font-size: 11px; color: #58a6ff; flex: 1;">${fav.name}</span>
                        <button onclick="removeFavorite('${fav.hash}'); event.stopPropagation();" style="background: none; border: none; color: #ff7b72; cursor: pointer; font-size: 12px; padding: 2px 4px; margin-left: 6px;">×</button>
                    </div>
                `;
            });
            
            list.innerHTML = html;
        }

        function toggleFavoritesSection() {
            const list = document.getElementById('favorites-list');
            const button = document.getElementById('favorites-toggle');
            
            if (list.style.display === 'none') {
                list.style.display = 'block';
                button.textContent = 'Hide';
            } else {
                list.style.display = 'none';
                button.textContent = 'Show';
            }
        }

        function removeFavorite(hash) {
            console.log('removeFavorite called with hash:', hash);
            const index = favoriteNodes.findIndex(fav => fav.hash === hash);
            
            if (index >= 0) {
                favoriteNodes.splice(index, 1);
                console.log('Removed favorite, new count:', favoriteNodes.length);
                saveFavorites();
                updateFavoritesDisplay();
                updateNodes(); // Refresh to update star icons
            }
        }

        document.addEventListener('keydown', (e) => {
            // Tab navigation with left/right arrows (with Ctrl/Cmd)
            if ((e.ctrlKey || e.metaKey) && !e.shiftKey) {
                switch (e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        switchToPreviousTab();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        switchToNextTab();
                        break;
                    case 'x': 
                        e.preventDefault();
                        closeOtherTabs();
                        break;
                }
            }
            
            if (e.altKey && !e.ctrlKey && !e.metaKey) {
                switch (e.key) {
                    case 'n':
                        e.preventDefault();
                        createNewTab();
                        break;
                    case 'x':
                        e.preventDefault();
                        if (activeTabId && tabs.length > 1) {
                            closeTab(activeTabId);
                        }
                        break;
                    case 'b':
                        e.preventDefault();
                        refreshPageTab();
                        break;
                }
            }
        });

        // Add these new functions for tab navigation:
        function switchToPreviousTab() {
            if (tabs.length <= 1) return;
            
            const currentIndex = tabs.findIndex(tab => tab.id === activeTabId);
            const previousIndex = currentIndex > 0 ? currentIndex - 1 : tabs.length - 1;
            switchToTab(tabs[previousIndex].id);
        }

        function switchToNextTab() {
            if (tabs.length <= 1) return;
            
            const currentIndex = tabs.findIndex(tab => tab.id === activeTabId);
            const nextIndex = currentIndex < tabs.length - 1 ? currentIndex + 1 : 0;
            switchToTab(tabs[nextIndex].id);
        }

        function closeOtherTabs() {
            if (tabs.length <= 1) return; // Nothing to close if only one tab
            
            const currentActiveTab = getActiveTab();
            if (!currentActiveTab) return;
            
            // Create array of tabs to close (all except active)
            const tabsToClose = tabs.filter(tab => tab.id !== activeTabId);
            
            // Close all other tabs
            tabsToClose.forEach(tab => {
                // Remove DOM elements
                document.querySelector(`[data-tab-id="${tab.id}"]`)?.remove();
                document.getElementById(tab.id)?.remove();
            });
            
            // Update tabs array to only contain the active tab
            tabs = [currentActiveTab];
            
            console.log('Closed all tabs except active tab:', currentActiveTab.title);
        }

        // Initialize everything when page loads
        // REPLACE the end of your existing DOMContentLoaded with this:
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('NomadNet Browser starting...');
            await initializeMicronParser();
            loadFavorites();
            
            // CREATE FIRST TAB
            createNewTab();
            
            // Start regular updates
            setInterval(() => {
                updateNodes();
                updateStatus();
            }, 1500);
            
            // Initial load
            updateNodes();
            updateStatus();
            
            console.log('Browser initialization complete');
        });
    </script>
</body>
</html>